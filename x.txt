Operation X: DRY Global Rate Limiter Integration Checklist (For Any Module)

1. FRONTEND: Remove all legacy/module-specific rate limit logic.
2. FRONTEND: Import and use only centralized `handleRateLimitResponse` from `rateLimiter.js`, passing the module name.
3. FRONTEND: Update rate limit display and localStorage only after a backend response, using returned `limits`/`remaining`.
4. FRONTEND: Ensure all error and display logic is handled by the centralized function.
5. BACKEND: Always call the global rate-limiter worker with `{ fingerprint, module: <moduleName>, action: 'consume' }` before processing a request.
6. BACKEND: Always include `limits` and `remaining` at the TOP LEVEL of every response (success and 429), never inside `data`.
7. BACKEND: Remove any legacy/module-specific rate limit logic.
8. CONFIRM: No legacy/redundant rate limit code remains in the module (frontend or backend).
9. CONFIRM: The frontend always displays the true number of uses left, as returned by the backend.
10. CONFIRM: All rate limit logic is centralized in `rateLimiter.js` and the backend worker.
11. TEST: After every backend change, verify that generating from the module updates the rate limit display and `rateLimitStatus` in localStorage. If it does not, check the backend response structure and patch as needed.
12. PATCH: If `limits`/`remaining` are not at the top level, fix the backend to match this checklist.
13. FINAL TEST: Confirm the checklist is fully satisfied before moving to the next module.
