<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Payment Processing</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background-color: #000000;
        }
        .container {
            text-align: center;
            background: rgba(20, 20, 20, 0.95);
            color: #ffffff;
            padding: 2rem;
            border-radius: 8px;
            box-shadow: 0 2px 20px rgba(255,255,255,0.1);
            max-width: 400px;
            border: 1px solid rgba(255,255,255,0.1);
        }
        .spinner {
            border: 4px solid rgba(255,255,255,0.2);
            border-top: 4px solid #ffffff;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 1rem;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .success {
            color: #4ade80;
        }
        .error {
            color: #f87171;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="spinner" id="spinner"></div>
        <h2 id="status">Processing your payment...</h2>
        <p id="message">Please wait while we verify your payment and update your account.</p>
        <div id="countdown" style="display: none;"></div>
    </div>

    <script>
        // Update UI
        function updateUI(status, message, isError = false) {
            document.getElementById('spinner').style.display = isError ? 'none' : 'block';
            document.getElementById('status').textContent = status;
            document.getElementById('status').className = isError ? 'error' : 'success';
            document.getElementById('message').textContent = message;
        }

        // Generate device fingerprint (matching rateLimiter.js)
        function generateDeviceFingerprint() {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            ctx.textBaseline = 'top';
            ctx.font = '14px Arial';
            ctx.fillText('Fingerprint test', 2, 2);
            const canvasFingerprint = canvas.toDataURL();
            
            const fingerprint = [
                navigator.userAgent,
                navigator.language,
                screen.width + 'x' + screen.height,
                screen.colorDepth,
                new Date().getTimezoneOffset(),
                navigator.platform,
                navigator.cookieEnabled,
                canvasFingerprint.slice(-50) // Last 50 chars of canvas fingerprint
            ].join('|');
            
            // Simple hash function
            let hash = 0;
            for (let i = 0; i < fingerprint.length; i++) {
                const char = fingerprint.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash; // Convert to 32-bit integer
            }
            
            return Math.abs(hash).toString(36);
        }

        // Generate session ID
        function generateSessionId() {
            return Date.now().toString(36) + Math.random().toString(36).substr(2);
        }

        // Get or create fingerprint (matching rateLimiter.js structure)
        function getFingerprint() {
            const FINGERPRINT_KEY = '_userFingerprint';
            
            try {
                const stored = localStorage.getItem(FINGERPRINT_KEY);
                let fingerprintData;
                
                if (stored) {
                    try {
                        fingerprintData = JSON.parse(stored);
                        // Check if session expired (24 hours)
                        const sessionAge = Date.now() - fingerprintData.sessionCreated;
                        if (sessionAge > 24 * 60 * 60 * 1000) {
                            // Create new session but keep device ID
                            fingerprintData.sessionId = generateSessionId();
                            fingerprintData.sessionCreated = Date.now();
                            fingerprintData.requestCounts = {};
                            fingerprintData.lastRequestTimes = [];
                        }
                    } catch (e) {
                        fingerprintData = null;
                    }
                }
                
                if (!fingerprintData || !fingerprintData.deviceId) {
                    fingerprintData = {
                        deviceId: generateDeviceFingerprint(),
                        sessionId: generateSessionId(),
                        sessionCreated: Date.now(),
                        requestCounts: {},
                        lastRequestTimes: [],
                        rateLimitStatus: {}
                    };
                }
                
                // Save updated fingerprint
                localStorage.setItem(FINGERPRINT_KEY, JSON.stringify(fingerprintData));
                return fingerprintData;
                
            } catch (error) {
                // Return minimal fingerprint if storage fails
                return {
                    deviceId: generateDeviceFingerprint(),
                    sessionId: generateSessionId(),
                    sessionCreated: Date.now(),
                    requestCounts: {},
                    lastRequestTimes: [],
                    rateLimitStatus: {}
                };
            }
        }

        // Main processing function
        async function processPayment() {
            try {
                // Get session ID from URL
                const urlParams = new URLSearchParams(window.location.search);
                const sessionId = urlParams.get('session_id');
                
                if (!sessionId) {
                    throw new Error('No session ID found in URL');
                }

                // Get or create fingerprint
                const fingerprint = getFingerprint();
                
                // Step 1: Verify payment with backend
                let checkResponse;
                try {
                    checkResponse = await fetch('https://stripeintegration.4hm7q4q75z.workers.dev/', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            task: 'checkPayment',
                            sessionId: sessionId,
                            fingerprint: fingerprint
                        })
                    });
                } catch (networkError) {
                    throw new Error('Network error: Unable to connect to payment server. Please check your internet connection.');
                }

                if (!checkResponse) {
                    throw new Error('Server returned null response');
                }

                if (!checkResponse.ok) {
                    const errorText = await checkResponse.text();
                    throw new Error('Payment verification failed: ' + checkResponse.status + ' - ' + errorText);
                }

                let checkData;
                try {
                    checkData = await checkResponse.json();
                } catch (parseError) {
                    throw new Error('Invalid response from server: ' + parseError.message);
                }

                if (!checkData || checkData.paymentStatus !== 'paid') {
                    throw new Error('Payment not completed: ' + (checkData?.message || checkData?.paymentStatus || 'Unknown error'));
                }

                // Update localStorage
                localStorage.setItem('authenticated', 'paid');

                // Create rateLimitStatus from checkData response (no additional API call needed)
                if (checkData.rateLimitStatus) {
                    localStorage.setItem('rateLimitStatus', JSON.stringify(checkData.rateLimitStatus));
                } else if (checkData.limits && checkData.remaining) {
                    // Fallback: create rateLimitStatus manually
                    const rateLimitStatus = {
                        allowed: true,
                        isPaid: true,
                        limits: checkData.limits,
                        remaining: checkData.remaining,
                        username: checkData.username,
                        lastUpdated: Date.now()
                    };
                    
                    localStorage.setItem('rateLimitStatus', JSON.stringify(rateLimitStatus));
                }

                // Success!
                document.getElementById('spinner').style.display = 'none';
                
                // Check URL for flow type
                const currentUrl = window.location.href;
                const currentDomain = window.location.origin;
                const hasFlowService = currentUrl.includes('flow=service');
                
                // Check if this is a business service payment
                if (hasFlowService) {
                    // Redirect to business service setup
                    const serviceUrl = currentDomain + '/business/oauth-connect.html?session_id=' + sessionId + '&flow=service';
                    window.location.href = serviceUrl;
                } else {
                    // Redirect to main app landing page
                    window.location.href = '/ai/landing/landing.html';
                }

            } catch (error) {
                updateUI('Payment Processing Failed', error.message, true);
                
                // On error, redirect to landing page after a delay
                setTimeout(() => {
                    window.location.href = '/ai/landing/landing.html';
                }, 3000);
            }
        }

        // Start processing when page loads
        document.addEventListener('DOMContentLoaded', processPayment);
    </script>
</body>
</html>
